<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>{{ symbol }} - Chart</title>
    <script src="https://unpkg.com/lightweight-charts@4.2.3/dist/lightweight-charts.standalone.production.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        :root {
            --primary: #6366f1;
            --success: #10b981;
            --danger: #ef4444;
            --warning: #f59e0b;
            --cyan: #06b6d4;
            --bg: linear-gradient(135deg, #0a0e27 0%, #1a1f3a 100%);
            --bg-card: rgba(30, 41, 59, 0.6);
            --text: #f1f5f9;
            --text-muted: #94a3b8;
            --border: rgba(148, 163, 184, 0.2);
        }
        
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: var(--bg);
            color: var(--text);
            line-height: 1.6;
            min-height: 100vh;
            padding-bottom: 1rem;
        }
        
        /* Navigation Bar */
        .navbar {
            background: rgba(30, 41, 59, 0.9);
            backdrop-filter: blur(20px);
            border-bottom: 1px solid var(--border);
            padding: 0.75rem 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: sticky;
            top: 0;
            z-index: 1000;
        }
        
        .navbar-brand {
            font-size: 1.1rem;
            font-weight: 700;
            color: var(--primary);
            text-decoration: none;
        }
        
        .back-btn {
            color: var(--text-muted);
            text-decoration: none;
            font-size: 0.875rem;
            font-weight: 500;
        }
        
        /* Container */
        .container {
            padding: 1rem;
            max-width: 100%;
        }
        
        /* Header */
        .symbol-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding: 1rem;
            background: var(--bg-card);
            backdrop-filter: blur(10px);
            border: 1px solid var(--border);
            border-radius: 12px;
        }
        
        .symbol-info {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }
        
        .symbol-name {
            font-size: 1.5rem;
            font-weight: 700;
        }
        
        .symbol-price {
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--success);
        }
        
        .symbol-badge {
            padding: 0.4rem 0.8rem;
            border-radius: 8px;
            font-size: 0.75rem;
            font-weight: 600;
        }
        
        .badge-bullish {
            background: rgba(16, 185, 129, 0.2);
            color: var(--success);
        }
        
        .badge-bearish {
            background: rgba(239, 68, 68, 0.2);
            color: var(--danger);
        }
        
        .badge-neutral {
            background: rgba(148, 163, 184, 0.2);
            color: var(--text-muted);
        }
        
        /* Timeframe Selector */
        .timeframe-selector {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }
        
        .timeframe-btn {
            flex: 1;
            padding: 0.75rem;
            border: 1px solid var(--border);
            background: var(--bg-card);
            color: var(--text);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 500;
            font-size: 0.875rem;
        }
        
        .timeframe-btn.active {
            background: var(--primary);
            border-color: var(--primary);
            color: white;
        }
        
        /* Chart Container */
        .chart-wrapper {
            background: var(--bg-card);
            backdrop-filter: blur(10px);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 1rem;
            margin-bottom: 1rem;
        }
        
        .chart-container {
            position: relative;
            height: 400px;
            width: 100%;
        }
        
        /* Position Info */
        .position-info {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.75rem;
            margin-top: 1rem;
        }
        
        .info-card {
            background: rgba(255, 255, 255, 0.03);
            padding: 0.75rem;
            border-radius: 8px;
            border-left: 3px solid var(--primary);
        }
        
        .info-label {
            color: var(--text-muted);
            font-size: 0.7rem;
            text-transform: uppercase;
            margin-bottom: 0.25rem;
        }
        
        .info-value {
            font-size: 1rem;
            font-weight: 600;
        }
        
        .info-value.positive {
            color: var(--success);
        }
        
        .info-value.negative {
            color: var(--danger);
        }
        
        /* Legend */
        .chart-legend {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.5rem;
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid var(--border);
            font-size: 0.75rem;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .legend-color {
            width: 16px;
            height: 2px;
            border-radius: 2px;
        }
    </style>
</head>
<body>
    <!-- Navigation Bar -->
    <nav class="navbar">
        <a href="/mobile" class="navbar-brand">üéØ Contrarian Bot</a>
        <a href="/mobile" class="back-btn">‚Üê Back</a>
    </nav>

    <div class="container">
        <!-- Symbol Header -->
        <div class="symbol-header">
            <div class="symbol-info">
                <div class="symbol-name" id="symbol-name">{{ symbol }}</div>
                <div class="symbol-price" id="symbol-price">Loading...</div>
            </div>
            <div>
                <span class="symbol-badge" id="symbol-badge">LOADING...</span>
            </div>
        </div>

        <!-- Timeframe Selector -->
        <div class="timeframe-selector">
            <button class="timeframe-btn active" onclick="switchTimeframe('4h')">4H</button>
            <button class="timeframe-btn" onclick="switchTimeframe('1h')">1H</button>
        </div>

        <!-- Chart Container -->
        <div class="chart-wrapper">
            <div class="chart-container" id="chartContainer"></div>
            
            <!-- Chart Legend -->
            <div class="chart-legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: #f59e0b;"></div>
                    <span>EMA 200</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #10b981;"></div>
                    <span>ST 4H</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #ef4444;"></div>
                    <span>ST 1H</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #6366f1;"></div>
                    <span>Entry</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #10b981;"></div>
                    <span>TP Target</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #06b6d4;"></div>
                    <span>Price</span>
                </div>
            </div>
        </div>

        <!-- Position Info -->
        <div class="position-info" id="position-info" style="display: none;">
            <div class="info-card">
                <div class="info-label">Position</div>
                <div class="info-value" id="position-side">-</div>
            </div>
            <div class="info-card">
                <div class="info-label">Entry Price</div>
                <div class="info-value" id="entry-price">-</div>
            </div>
            <div class="info-card">
                <div class="info-label">Current Price</div>
                <div class="info-value" id="current-price">-</div>
            </div>
            <div class="info-card">
                <div class="info-label">Unrealized PnL</div>
                <div class="info-value" id="unrealized-pnl">-</div>
            </div>
            <div class="info-card">
                <div class="info-label">Size</div>
                <div class="info-value" id="position-size">-</div>
            </div>
            <div class="info-card">
                <div class="info-label">TP Status</div>
                <div class="info-value" id="partial-tp-status">-</div>
            </div>
        </div>
        
        <div id="no-position" style="text-align: center; padding: 1rem; color: var(--text-muted); font-size: 0.875rem;">
            No open position for this symbol
        </div>
    </div>

    <script>
        const symbol = '{{ symbol }}';
        console.log('Symbol:', symbol);
        
        if (!symbol || symbol === '') {
            console.error('Invalid symbol!');
            document.getElementById('symbol-price').textContent = 'Error: Invalid symbol';
        }
        
        let chart;
        let candlestickSeries;
        let emaSeries;
        let st4hSeries;
        let st1hSeries;
        let entryPriceSeries;
        let partialTPSeries;
        let currentPriceSeries;
        let currentTimeframe = '4h';
        let chartData = null;
        let isFirstLoad = true;
        let userHasZoomed = false;

        async function loadChartData() {
            try {
                console.log('Loading chart data for', symbol);
                const priceEl = document.getElementById('symbol-price');
                if (priceEl) {
                    priceEl.textContent = 'Loading...';
                }
                
                const response = await fetch(`/api/symbol/${symbol}/chart-data`);
                console.log('Response status:', response.status);
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                console.log('Chart data received');
                
                if (data.error) {
                    console.error('Error loading chart data:', data.error);
                    if (priceEl) {
                        priceEl.textContent = `Error: ${data.error}`;
                    }
                    const badgeEl = document.getElementById('symbol-badge');
                    if (badgeEl) {
                        badgeEl.textContent = 'ERROR';
                    }
                    return;
                }
                
                chartData = data;
                console.log('chartData set, has position:', !!chartData.position);
                
                // Set candlesticks immediately
                try {
                    const candles = currentTimeframe === '4h' ? data.candles_4h : data.candles_1h;
                    if (candles && candles.length > 0 && candlestickSeries) {
                        const candlestickData = convertCandles(candles);
                        if (candlestickData.length > 0) {
                            candlestickData.sort((a, b) => a.time - b.time);
                            candlestickSeries.setData(candlestickData);
                            console.log('‚úÖ Candlesticks set immediately');
                        }
                    }
                } catch (error) {
                    console.error('‚ùå Error setting candlesticks:', error);
                }
                
                // Update header
                let currentPrice = data.current_price || 0;
                if (currentPrice <= 0) {
                    const candles = data.candles_4h || data.candles_1h || [];
                    if (candles.length > 0) {
                        const lastCandle = candles[candles.length - 1];
                        currentPrice = parseFloat(lastCandle[4]);
                    }
                }
                
                if (currentPrice > 0) {
                    document.getElementById('symbol-price').textContent = `$${currentPrice.toFixed(2)}`;
                } else {
                    document.getElementById('symbol-price').textContent = 'N/A';
                }
                
                // Determine badge
                let badge = 'NEUTRAL';
                let badgeClass = 'badge-neutral';
                if (data.indicators && data.indicators.ema200_4h && data.indicators.st_4h_direction && currentPrice > 0) {
                    const emaBullish = data.indicators.ema200_4h < currentPrice;
                    const stBullish = data.indicators.st_4h_direction === 'green';
                    if (emaBullish && stBullish) {
                        badge = 'BULLISH';
                        badgeClass = 'badge-bullish';
                    } else if (!emaBullish && !stBullish) {
                        badge = 'BEARISH';
                        badgeClass = 'badge-bearish';
                    }
                }
                const badgeEl = document.getElementById('symbol-badge');
                badgeEl.textContent = badge;
                badgeEl.className = `symbol-badge ${badgeClass}`;
                
                // Update position info
                try {
                    if (data.position) {
                        document.getElementById('position-info').style.display = 'grid';
                        document.getElementById('no-position').style.display = 'none';
                        
                        document.getElementById('position-side').textContent = data.position.side;
                        document.getElementById('entry-price').textContent = `$${data.position.entry_price.toFixed(2)}`;
                        document.getElementById('current-price').textContent = `$${data.position.current_price.toFixed(2)}`;
                        
                        const pnlEl = document.getElementById('unrealized-pnl');
                        const pnlSign = data.position.unrealized_pnl >= 0 ? '+' : '';
                        pnlEl.textContent = `${pnlSign}$${data.position.unrealized_pnl.toFixed(2)}`;
                        pnlEl.className = `info-value ${data.position.unrealized_pnl >= 0 ? 'positive' : 'negative'}`;
                        
                        document.getElementById('position-size').textContent = `${data.position.position_size} ${symbol.replace('USDT', '')}`;
                        
                        const tpStatusEl = document.getElementById('partial-tp-status');
                        if (data.position.partial_tp_done) {
                            tpStatusEl.textContent = '‚úÖ Done';
                            tpStatusEl.className = 'info-value positive';
                        } else {
                            tpStatusEl.textContent = '‚è≥ Pending';
                            tpStatusEl.className = 'info-value';
                        }
                    } else {
                        document.getElementById('position-info').style.display = 'none';
                        document.getElementById('no-position').style.display = 'block';
                    }
                } catch (error) {
                    console.error('Error updating position info:', error);
                }
                
                // Load chart data
                if (typeof candlestickSeries === 'undefined' || candlestickSeries === null) {
                    setTimeout(() => {
                        loadData(currentTimeframe);
                    }, 200);
                } else {
                    try {
                        loadData(currentTimeframe);
                    } catch (error) {
                        console.error('Error in loadData:', error);
                    }
                }
            } catch (error) {
                console.error('Error loading chart data:', error);
                const priceEl = document.getElementById('symbol-price');
                if (priceEl) {
                    priceEl.textContent = 'Error: ' + error.message;
                }
            }
        }

        function convertCandles(candles) {
            if (!candles || candles.length === 0) return [];
            
            return candles.map((c) => {
                if (Array.isArray(c) && c.length >= 5) {
                    const time = Math.floor(parseInt(c[0]) / 1000);
                    const open = parseFloat(c[1]);
                    const high = parseFloat(c[2]);
                    const low = parseFloat(c[3]);
                    const close = parseFloat(c[4]);
                    
                    if (isNaN(time) || isNaN(open) || isNaN(high) || isNaN(low) || isNaN(close)) {
                        return null;
                    }
                    
                    return { time, open, high, low, close };
                }
                return null;
            }).filter(c => c !== null);
        }

        function initChart() {
            const container = document.getElementById('chartContainer');
            if (!container) {
                console.error('Chart container not found!');
                return;
            }
            
            if (typeof LightweightCharts === 'undefined') {
                console.error('LightweightCharts library not loaded!');
                return;
            }
            
            try {
                chart = LightweightCharts.createChart(container, {
                    layout: {
                        background: { color: 'transparent' },
                        textColor: '#94a3b8',
                        fontSize: 12,
                    },
                    grid: {
                        vertLines: { color: '#334155' },
                        horzLines: { color: '#334155' },
                    },
                    crosshair: {
                        mode: LightweightCharts.CrosshairMode.Normal,
                    },
                    rightPriceScale: {
                        borderColor: '#334155',
                    },
                    timeScale: {
                        borderColor: '#334155',
                        timeVisible: true,
                    },
                });
                
                candlestickSeries = chart.addCandlestickSeries({
                    upColor: '#10b981',
                    downColor: '#ef4444',
                    borderVisible: false,
                    wickUpColor: '#10b981',
                    wickDownColor: '#ef4444',
                });

                emaSeries = chart.addLineSeries({
                    color: '#f59e0b',
                    lineWidth: 2,
                    title: 'EMA 200',
                });

                st4hSeries = chart.addLineSeries({
                    color: '#10b981',
                    lineWidth: 2,
                    lineStyle: LightweightCharts.LineStyle.Dashed,
                    title: 'SuperTrend 4H',
                });

                st1hSeries = chart.addLineSeries({
                    color: '#ef4444',
                    lineWidth: 2,
                    lineStyle: LightweightCharts.LineStyle.Dashed,
                    title: 'SuperTrend 1H',
                });

                entryPriceSeries = chart.addLineSeries({
                    color: '#6366f1',
                    lineWidth: 2,
                    lineStyle: LightweightCharts.LineStyle.Dashed,
                    title: 'Entry Price',
                });

                partialTPSeries = chart.addLineSeries({
                    color: '#10b981',
                    lineWidth: 2,
                    lineStyle: LightweightCharts.LineStyle.Dotted,
                    title: 'Partial TP Target',
                });

                currentPriceSeries = chart.addLineSeries({
                    color: '#06b6d4',
                    lineWidth: 2,
                    lineStyle: LightweightCharts.LineStyle.Dashed,
                    title: 'Current Price',
                });
                
                loadChartData();
            } catch (error) {
                console.error('Error initializing chart:', error);
            }
        }

        function loadData(timeframe) {
            if (!chartData) return;
            
            const candles = timeframe === '4h' ? chartData.candles_4h : chartData.candles_1h;
            if (!candles || candles.length === 0) return;
            
            const candlestickData = convertCandles(candles);
            if (candlestickData.length === 0) return;
            
            candlestickData.sort((a, b) => a.time - b.time);
            const firstCandle = candlestickData[0];
            const lastCandle = candlestickData[candlestickData.length - 1];
            
            try {
                candlestickSeries.setData(candlestickData);
            } catch (error) {
                console.error('Error setting candlesticks:', error);
            }
            
            // EMA 200
            let emaData = [];
            try {
                if (timeframe === '4h' && chartData.indicators && chartData.indicators.ema200_4h) {
                    const emaValue = parseFloat(chartData.indicators.ema200_4h);
                    if (!isNaN(emaValue) && emaValue > 0) {
                        emaData = [
                            { time: firstCandle.time, value: emaValue },
                            { time: lastCandle.time, value: emaValue }
                        ];
                    }
                }
            } catch (error) {
                console.error('Error creating EMA data:', error);
            }
            
            // SuperTrend
            let st4hData = [];
            let st1hData = [];
            try {
                if (timeframe === '4h' && chartData.indicators && chartData.indicators.st_4h_value) {
                    st4hData = [
                        { time: firstCandle.time, value: chartData.indicators.st_4h_value },
                        { time: lastCandle.time, value: chartData.indicators.st_4h_value }
                    ];
                }
                if (chartData.indicators && chartData.indicators.st_1h_value) {
                    st1hData = [
                        { time: firstCandle.time, value: chartData.indicators.st_1h_value },
                        { time: lastCandle.time, value: chartData.indicators.st_1h_value }
                    ];
                }
            } catch (error) {
                console.error('Error creating ST data:', error);
            }
            
            // Entry price
            let entryPriceData = [];
            let entryTime = null;
            try {
                if (chartData.position && chartData.position.entry_price) {
                    if (chartData.position.entry_time) {
                        const entryDate = new Date(chartData.position.entry_time);
                        if (!isNaN(entryDate.getTime())) {
                            entryTime = Math.floor(entryDate.getTime() / 1000);
                            if (entryTime < firstCandle.time) entryTime = firstCandle.time;
                            if (entryTime > lastCandle.time) entryTime = lastCandle.time;
                        } else {
                            entryTime = firstCandle.time;
                        }
                    } else {
                        entryTime = firstCandle.time;
                    }
                    
                    const entryPrice = parseFloat(chartData.position.entry_price);
                    if (!isNaN(entryPrice) && entryPrice > 0) {
                        entryPriceData = [
                            { time: entryTime, value: entryPrice },
                            { time: lastCandle.time, value: entryPrice }
                        ];
                    }
                }
            } catch (error) {
                console.error('Error processing entry price:', error);
            }
            
            // Partial TP
            let partialTPData = [];
            try {
                if (chartData.position && chartData.position.tp_target_price) {
                    const tpPrice = parseFloat(chartData.position.tp_target_price);
                    if (!isNaN(tpPrice) && tpPrice > 0) {
                        const startTime = entryTime || firstCandle.time;
                        partialTPData = [
                            { time: startTime, value: tpPrice },
                            { time: lastCandle.time, value: tpPrice }
                        ];
                    }
                }
            } catch (error) {
                console.error('Error processing TP data:', error);
            }
            
            // Current price
            let currentPrice = parseFloat(chartData.current_price) || 0;
            if (currentPrice <= 0 || isNaN(currentPrice)) {
                currentPrice = lastCandle.close;
            }
            const currentPriceData = (currentPrice > 0 && !isNaN(currentPrice)) ? [
                { time: firstCandle.time, value: currentPrice },
                { time: lastCandle.time, value: currentPrice }
            ] : [];
            
            // Set all series
            try {
                if (timeframe === '4h' && emaData.length > 0) {
                    emaSeries.setData(emaData);
                } else {
                    emaSeries.setData([]);
                }
            } catch (error) {
                console.error('Error setting EMA:', error);
            }
            
            try {
                if (timeframe === '4h' && st4hData.length > 0) {
                    st4hSeries.setData(st4hData);
                } else {
                    st4hSeries.setData([]);
                }
            } catch (error) {
                console.error('Error setting ST 4H:', error);
            }
            
            try {
                if (st1hData.length > 0) {
                    st1hSeries.setData(st1hData);
                } else {
                    st1hSeries.setData([]);
                }
            } catch (error) {
                console.error('Error setting ST 1H:', error);
            }
            
            try {
                if (entryPriceData.length > 0) {
                    entryPriceSeries.setData(entryPriceData);
                } else {
                    entryPriceSeries.setData([]);
                }
            } catch (error) {
                console.error('Error setting entry price:', error);
            }
            
            try {
                if (partialTPData.length > 0) {
                    partialTPSeries.setData(partialTPData);
                } else {
                    partialTPSeries.setData([]);
                }
            } catch (error) {
                console.error('Error setting TP:', error);
            }
            
            try {
                if (currentPriceData.length > 0) {
                    currentPriceSeries.setData(currentPriceData);
                } else {
                    currentPriceSeries.setData([]);
                }
            } catch (error) {
                console.error('Error setting current price:', error);
            }
            
            // Markers
            const markers = [];
            try {
                if (entryTime && chartData.position) {
                    markers.push({
                        time: entryTime,
                        position: chartData.position.side === 'LONG' ? 'belowBar' : 'aboveBar',
                        color: '#6366f1',
                        shape: chartData.position.side === 'LONG' ? 'arrowUp' : 'arrowDown',
                        text: `ENTRY ${chartData.position.side}`,
                        size: 1.2,
                    });
                    
                    if (chartData.position.partial_tp_done) {
                        markers.push({
                            time: lastCandle.time,
                            position: chartData.position.side === 'LONG' ? 'aboveBar' : 'belowBar',
                            color: '#10b981',
                            shape: chartData.position.side === 'LONG' ? 'arrowDown' : 'arrowUp',
                            text: 'TP ‚úÖ',
                            size: 1.2,
                        });
                    }
                }
            } catch (error) {
                console.error('Error creating markers:', error);
            }
            
            try {
                candlestickSeries.setMarkers(markers);
            } catch (error) {
                console.error('Error setting markers:', error);
            }
            
            // Save viewport before updating (if user has zoomed)
            let savedVisibleRange = null;
            if (userHasZoomed && chart && chart.timeScale) {
                try {
                    savedVisibleRange = chart.timeScale().getVisibleRange();
                    console.log('Saved visible range:', savedVisibleRange);
                } catch (e) {
                    console.warn('Could not save visible range:', e);
                }
            }
            
            // Only fit content on first load or when switching timeframes
            try {
                if (isFirstLoad) {
                    chart.timeScale().fitContent();
                    isFirstLoad = false;
                    console.log('=== loadData END (first load, fitContent) ===');
                } else if (savedVisibleRange) {
                    // Restore saved viewport
                    chart.timeScale().setVisibleRange(savedVisibleRange);
                    console.log('=== loadData END (restored viewport) ===');
                } else {
                    console.log('=== loadData END (no viewport change) ===');
                }
            } catch (error) {
                console.error('Error managing viewport:', error);
            }
            
            // Track user interactions (zoom/pan)
            if (chart && chart.timeScale) {
                chart.timeScale().subscribeVisibleTimeRangeChange(() => {
                    if (!isFirstLoad) {
                        userHasZoomed = true;
                    }
                });
            }
        }

        function switchTimeframe(timeframe) {
            currentTimeframe = timeframe;
            isFirstLoad = true; // Reset on timeframe switch to fit content
            userHasZoomed = false; // Reset zoom tracking
            
            document.querySelectorAll('.timeframe-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            loadData(timeframe);
        }

        function startApp() {
            if (typeof LightweightCharts === 'undefined') {
                setTimeout(startApp, 100);
                return;
            }
            
            try {
                initChart();
                setInterval(loadChartData, 30000);
            } catch (error) {
                console.error('Error starting app:', error);
            }
        }
        
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                setTimeout(startApp, 200);
            });
        } else {
            setTimeout(startApp, 200);
        }
    </script>
</body>
</html>

